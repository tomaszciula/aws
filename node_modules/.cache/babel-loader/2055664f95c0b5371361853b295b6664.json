{"ast":null,"code":"import { __assign, __awaiter, __generator, __read } from \"tslib\";\nimport { memoize } from \"@aws-sdk/property-provider\";\nimport { SignatureV4 } from \"@aws-sdk/signature-v4\"; // 5 minutes buffer time the refresh the credential before it really expires\n\nvar CREDENTIAL_EXPIRE_WINDOW = 300000;\nexport var resolveAwsAuthConfig = function (input) {\n  var normalizedCreds = input.credentials ? normalizeCredentialProvider(input.credentials) : input.credentialDefaultProvider(input);\n  var _a = input.signingEscapePath,\n      signingEscapePath = _a === void 0 ? true : _a,\n      _b = input.systemClockOffset,\n      systemClockOffset = _b === void 0 ? input.systemClockOffset || 0 : _b,\n      sha256 = input.sha256;\n  var signer;\n\n  if (input.signer) {\n    //if signer is supplied by user, normalize it to a function returning a promise for signer.\n    signer = normalizeProvider(input.signer);\n  } else {\n    //construct a provider inferring signing from region.\n    signer = function () {\n      return normalizeProvider(input.region)().then(function (region) {\n        return __awaiter(void 0, void 0, void 0, function () {\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                return [4\n                /*yield*/\n                , input.regionInfoProvider(region)];\n\n              case 1:\n                return [2\n                /*return*/\n                , [_a.sent() || {}, region]];\n            }\n          });\n        });\n      }).then(function (_a) {\n        var _b = __read(_a, 2),\n            regionInfo = _b[0],\n            region = _b[1];\n\n        var signingRegion = regionInfo.signingRegion,\n            signingService = regionInfo.signingService; //update client's singing region and signing service config if they are resolved.\n        //signing region resolving order: user supplied signingRegion -> endpoints.json inferred region -> client region\n\n        input.signingRegion = input.signingRegion || signingRegion || region; //signing name resolving order:\n        //user supplied signingName -> endpoints.json inferred (credential scope -> model arnNamespace) -> model service id\n\n        input.signingName = input.signingName || signingService || input.serviceId;\n        return new SignatureV4({\n          credentials: normalizedCreds,\n          region: input.signingRegion,\n          service: input.signingName,\n          sha256: sha256,\n          uriEscapePath: signingEscapePath\n        });\n      });\n    };\n  }\n\n  return __assign(__assign({}, input), {\n    systemClockOffset: systemClockOffset,\n    signingEscapePath: signingEscapePath,\n    credentials: normalizedCreds,\n    signer: signer\n  });\n}; // TODO: reduce code duplication\n\nexport var resolveSigV4AuthConfig = function (input) {\n  var normalizedCreds = input.credentials ? normalizeCredentialProvider(input.credentials) : input.credentialDefaultProvider(input);\n  var _a = input.signingEscapePath,\n      signingEscapePath = _a === void 0 ? true : _a,\n      _b = input.systemClockOffset,\n      systemClockOffset = _b === void 0 ? input.systemClockOffset || 0 : _b,\n      sha256 = input.sha256;\n  var signer;\n\n  if (input.signer) {\n    //if signer is supplied by user, normalize it to a function returning a promise for signer.\n    signer = normalizeProvider(input.signer);\n  } else {\n    signer = normalizeProvider(new SignatureV4({\n      credentials: normalizedCreds,\n      region: input.region,\n      service: input.signingName,\n      sha256: sha256,\n      uriEscapePath: signingEscapePath\n    }));\n  }\n\n  return __assign(__assign({}, input), {\n    systemClockOffset: systemClockOffset,\n    signingEscapePath: signingEscapePath,\n    credentials: normalizedCreds,\n    signer: signer\n  });\n};\n\nvar normalizeProvider = function (input) {\n  if (typeof input === \"object\") {\n    var promisified_1 = Promise.resolve(input);\n    return function () {\n      return promisified_1;\n    };\n  }\n\n  return input;\n};\n\nvar normalizeCredentialProvider = function (credentials) {\n  if (typeof credentials === \"function\") {\n    return memoize(credentials, function (credentials) {\n      return credentials.expiration !== undefined && credentials.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW;\n    }, function (credentials) {\n      return credentials.expiration !== undefined;\n    });\n  }\n\n  return normalizeProvider(credentials);\n};","map":{"version":3,"sources":["../../src/configurations.ts"],"names":[],"mappings":"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","sourcesContent":["import { memoize } from \"@aws-sdk/property-provider\";\nimport { SignatureV4 } from \"@aws-sdk/signature-v4\";\nimport { Credentials, HashConstructor, Provider, RegionInfo, RegionInfoProvider, RequestSigner } from \"@aws-sdk/types\";\n\n// 5 minutes buffer time the refresh the credential before it really expires\nconst CREDENTIAL_EXPIRE_WINDOW = 300000;\n\n// AwsAuth v/s SigV4Auth\n// AwsAuth: specific to SigV4 auth for AWS services\n// SigV4Auth: SigV4 auth for non-AWS services\n\nexport interface AwsAuthInputConfig {\n  /**\n   * The credentials used to sign requests.\n   */\n  credentials?: Credentials | Provider<Credentials>;\n\n  /**\n   * The signer to use when signing requests.\n   */\n  signer?: RequestSigner | Provider<RequestSigner>;\n\n  /**\n   * Whether to escape request path when signing the request.\n   */\n  signingEscapePath?: boolean;\n\n  /**\n   * An offset value in milliseconds to apply to all signing times.\n   */\n  systemClockOffset?: number;\n\n  /**\n   * The region where you want to sign your request against. This\n   * can be different to the region in the endpoint.\n   */\n  signingRegion?: string;\n}\n\nexport interface SigV4AuthInputConfig {\n  /**\n   * The credentials used to sign requests.\n   */\n  credentials?: Credentials | Provider<Credentials>;\n\n  /**\n   * The signer to use when signing requests.\n   */\n  signer?: RequestSigner | Provider<RequestSigner>;\n\n  /**\n   * Whether to escape request path when signing the request.\n   */\n  signingEscapePath?: boolean;\n\n  /**\n   * An offset value in milliseconds to apply to all signing times.\n   */\n  systemClockOffset?: number;\n}\n\ninterface PreviouslyResolved {\n  credentialDefaultProvider: (input: any) => Provider<Credentials>;\n  region: string | Provider<string>;\n  regionInfoProvider: RegionInfoProvider;\n  signingName?: string;\n  serviceId: string;\n  sha256: HashConstructor;\n}\n\ninterface SigV4PreviouslyResolved {\n  credentialDefaultProvider: (input: any) => Provider<Credentials>;\n  region: string | Provider<string>;\n  signingName: string;\n  sha256: HashConstructor;\n}\n\nexport interface AwsAuthResolvedConfig {\n  /**\n   * Resolved value for input config {@link AwsAuthInputConfig.credentials}\n   */\n  credentials: Provider<Credentials>;\n  /**\n   * Resolved value for input config {@link AwsAuthInputConfig.signer}\n   */\n  signer: Provider<RequestSigner>;\n  /**\n   * Resolved value for input config {@link AwsAuthInputConfig.signingEscapePath}\n   */\n  signingEscapePath: boolean;\n  /**\n   * Resolved value for input config {@link AwsAuthInputConfig.systemClockOffset}\n   */\n  systemClockOffset: number;\n}\n\nexport interface SigV4AuthResolvedConfig extends AwsAuthResolvedConfig {}\n\nexport const resolveAwsAuthConfig = <T>(\n  input: T & AwsAuthInputConfig & PreviouslyResolved\n): T & AwsAuthResolvedConfig => {\n  const normalizedCreds = input.credentials\n    ? normalizeCredentialProvider(input.credentials)\n    : input.credentialDefaultProvider(input as any);\n  const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;\n  let signer: Provider<RequestSigner>;\n  if (input.signer) {\n    //if signer is supplied by user, normalize it to a function returning a promise for signer.\n    signer = normalizeProvider(input.signer);\n  } else {\n    //construct a provider inferring signing from region.\n    signer = () =>\n      normalizeProvider(input.region)()\n        .then(async (region) => [(await input.regionInfoProvider(region)) || {}, region] as [RegionInfo, string])\n        .then(([regionInfo, region]) => {\n          const { signingRegion, signingService } = regionInfo;\n          //update client's singing region and signing service config if they are resolved.\n          //signing region resolving order: user supplied signingRegion -> endpoints.json inferred region -> client region\n          input.signingRegion = input.signingRegion || signingRegion || region;\n          //signing name resolving order:\n          //user supplied signingName -> endpoints.json inferred (credential scope -> model arnNamespace) -> model service id\n          input.signingName = input.signingName || signingService || input.serviceId;\n\n          return new SignatureV4({\n            credentials: normalizedCreds,\n            region: input.signingRegion,\n            service: input.signingName,\n            sha256,\n            uriEscapePath: signingEscapePath,\n          });\n        });\n  }\n\n  return {\n    ...input,\n    systemClockOffset,\n    signingEscapePath,\n    credentials: normalizedCreds,\n    signer,\n  };\n};\n\n// TODO: reduce code duplication\nexport const resolveSigV4AuthConfig = <T>(\n  input: T & SigV4AuthInputConfig & SigV4PreviouslyResolved\n): T & SigV4AuthResolvedConfig => {\n  const normalizedCreds = input.credentials\n    ? normalizeCredentialProvider(input.credentials)\n    : input.credentialDefaultProvider(input as any);\n  const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;\n  let signer: Provider<RequestSigner>;\n  if (input.signer) {\n    //if signer is supplied by user, normalize it to a function returning a promise for signer.\n    signer = normalizeProvider(input.signer);\n  } else {\n    signer = normalizeProvider(new SignatureV4({\n      credentials: normalizedCreds,\n      region: input.region,\n      service: input.signingName,\n      sha256,\n      uriEscapePath: signingEscapePath,\n    }));\n  }\n\n  return {\n    ...input,\n    systemClockOffset,\n    signingEscapePath,\n    credentials: normalizedCreds,\n    signer,\n  };\n};\n\nconst normalizeProvider = <T>(input: T | Provider<T>): Provider<T> => {\n  if (typeof input === \"object\") {\n    const promisified = Promise.resolve(input);\n    return () => promisified;\n  }\n  return input as Provider<T>;\n};\n\nconst normalizeCredentialProvider = (credentials: Credentials | Provider<Credentials>): Provider<Credentials> => {\n  if (typeof credentials === \"function\") {\n    return memoize(\n      credentials,\n      (credentials) =>\n        credentials.expiration !== undefined &&\n        credentials.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW,\n      (credentials) => credentials.expiration !== undefined\n    );\n  }\n  return normalizeProvider(credentials);\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}