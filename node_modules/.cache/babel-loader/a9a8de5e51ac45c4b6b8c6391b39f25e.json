{"ast":null,"code":"import { NO_RETRY_INCREMENT, RETRY_COST, TIMEOUT_RETRY_COST } from \"./constants\";\nexport var getDefaultRetryQuota = function (initialRetryTokens, options) {\n  var _a, _b, _c;\n\n  var MAX_CAPACITY = initialRetryTokens;\n  var noRetryIncrement = (_a = options === null || options === void 0 ? void 0 : options.noRetryIncrement) !== null && _a !== void 0 ? _a : NO_RETRY_INCREMENT;\n  var retryCost = (_b = options === null || options === void 0 ? void 0 : options.retryCost) !== null && _b !== void 0 ? _b : RETRY_COST;\n  var timeoutRetryCost = (_c = options === null || options === void 0 ? void 0 : options.timeoutRetryCost) !== null && _c !== void 0 ? _c : TIMEOUT_RETRY_COST;\n  var availableCapacity = initialRetryTokens;\n\n  var getCapacityAmount = function (error) {\n    return error.name === \"TimeoutError\" ? timeoutRetryCost : retryCost;\n  };\n\n  var hasRetryTokens = function (error) {\n    return getCapacityAmount(error) <= availableCapacity;\n  };\n\n  var retrieveRetryTokens = function (error) {\n    if (!hasRetryTokens(error)) {\n      // retryStrategy should stop retrying, and return last error\n      throw new Error(\"No retry token available\");\n    }\n\n    var capacityAmount = getCapacityAmount(error);\n    availableCapacity -= capacityAmount;\n    return capacityAmount;\n  };\n\n  var releaseRetryTokens = function (capacityReleaseAmount) {\n    availableCapacity += capacityReleaseAmount !== null && capacityReleaseAmount !== void 0 ? capacityReleaseAmount : noRetryIncrement;\n    availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n  };\n\n  return Object.freeze({\n    hasRetryTokens: hasRetryTokens,\n    retrieveRetryTokens: retrieveRetryTokens,\n    releaseRetryTokens: releaseRetryTokens\n  });\n};","map":{"version":3,"sources":["../../src/defaultRetryQuota.ts"],"names":[],"mappings":"AAEA,SAAS,kBAAT,EAA6B,UAA7B,EAAyC,kBAAzC,QAAmE,aAAnE;AAsBA,OAAO,IAAM,oBAAoB,GAAG,UAAC,kBAAD,EAA6B,OAA7B,EAA+D;;;AACjG,MAAM,YAAY,GAAG,kBAArB;AACA,MAAM,gBAAgB,GAAG,CAAA,EAAA,GAAA,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,gBAAT,MAAyB,IAAzB,IAAyB,EAAA,KAAA,KAAA,CAAzB,GAAyB,EAAzB,GAA6B,kBAAtD;AACA,MAAM,SAAS,GAAG,CAAA,EAAA,GAAA,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,SAAT,MAAkB,IAAlB,IAAkB,EAAA,KAAA,KAAA,CAAlB,GAAkB,EAAlB,GAAsB,UAAxC;AACA,MAAM,gBAAgB,GAAG,CAAA,EAAA,GAAA,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,gBAAT,MAAyB,IAAzB,IAAyB,EAAA,KAAA,KAAA,CAAzB,GAAyB,EAAzB,GAA6B,kBAAtD;AAEA,MAAI,iBAAiB,GAAG,kBAAxB;;AAEA,MAAM,iBAAiB,GAAG,UAAC,KAAD,EAAgB;AAAK,WAAC,KAAK,CAAC,IAAN,KAAe,cAAf,GAAgC,gBAAhC,GAAD,SAAA;AAA8D,GAA7G;;AAEA,MAAM,cAAc,GAAG,UAAC,KAAD,EAAgB;AAAK,WAAA,iBAAiB,CAAC,KAAD,CAAjB,IAAA,iBAAA;AAA6C,GAAzF;;AAEA,MAAM,mBAAmB,GAAG,UAAC,KAAD,EAAgB;AAC1C,QAAI,CAAC,cAAc,CAAC,KAAD,CAAnB,EAA4B;AAC1B;AACA,YAAM,IAAI,KAAJ,CAAU,0BAAV,CAAN;AACD;;AACD,QAAM,cAAc,GAAG,iBAAiB,CAAC,KAAD,CAAxC;AACA,IAAA,iBAAiB,IAAI,cAArB;AACA,WAAO,cAAP;AACD,GARD;;AAUA,MAAM,kBAAkB,GAAG,UAAC,qBAAD,EAA+B;AACxD,IAAA,iBAAiB,IAAI,qBAAqB,KAAA,IAArB,IAAA,qBAAqB,KAAA,KAAA,CAArB,GAAA,qBAAA,GAAyB,gBAA9C;AACA,IAAA,iBAAiB,GAAG,IAAI,CAAC,GAAL,CAAS,iBAAT,EAA4B,YAA5B,CAApB;AACD,GAHD;;AAKA,SAAO,MAAM,CAAC,MAAP,CAAc;AACnB,IAAA,cAAc,EAAA,cADK;AAEnB,IAAA,mBAAmB,EAAA,mBAFA;AAGnB,IAAA,kBAAkB,EAAA;AAHC,GAAd,CAAP;AAKD,CAhCM","sourcesContent":["import { SdkError } from \"@aws-sdk/types\";\n\nimport { NO_RETRY_INCREMENT, RETRY_COST, TIMEOUT_RETRY_COST } from \"./constants\";\nimport { RetryQuota } from \"./types\";\n\nexport interface DefaultRetryQuotaOptions {\n  /**\n   * The total amount of retry token to be incremented from retry token balance\n   * if an SDK operation invocation succeeds without requiring a retry request.\n   */\n  noRetryIncrement?: number;\n\n  /**\n   * The total amount of retry tokens to be decremented from retry token balance.\n   */\n  retryCost?: number;\n\n  /**\n   * The total amount of retry tokens to be decremented from retry token balance\n   * when a throttling error is encountered.\n   */\n  timeoutRetryCost?: number;\n}\n\nexport const getDefaultRetryQuota = (initialRetryTokens: number, options?: DefaultRetryQuotaOptions): RetryQuota => {\n  const MAX_CAPACITY = initialRetryTokens;\n  const noRetryIncrement = options?.noRetryIncrement ?? NO_RETRY_INCREMENT;\n  const retryCost = options?.retryCost ?? RETRY_COST;\n  const timeoutRetryCost = options?.timeoutRetryCost ?? TIMEOUT_RETRY_COST;\n\n  let availableCapacity = initialRetryTokens;\n\n  const getCapacityAmount = (error: SdkError) => (error.name === \"TimeoutError\" ? timeoutRetryCost : retryCost);\n\n  const hasRetryTokens = (error: SdkError) => getCapacityAmount(error) <= availableCapacity;\n\n  const retrieveRetryTokens = (error: SdkError) => {\n    if (!hasRetryTokens(error)) {\n      // retryStrategy should stop retrying, and return last error\n      throw new Error(\"No retry token available\");\n    }\n    const capacityAmount = getCapacityAmount(error);\n    availableCapacity -= capacityAmount;\n    return capacityAmount;\n  };\n\n  const releaseRetryTokens = (capacityReleaseAmount?: number) => {\n    availableCapacity += capacityReleaseAmount ?? noRetryIncrement;\n    availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n  };\n\n  return Object.freeze({\n    hasRetryTokens,\n    retrieveRetryTokens,\n    releaseRetryTokens,\n  });\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}