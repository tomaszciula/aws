{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n};\n\nimport { UploadPartCommand, CompleteMultipartUploadCommand, AbortMultipartUploadCommand, ListPartsCommand, CreateMultipartUploadCommand, ListObjectsV2Command } from '@aws-sdk/client-s3';\nimport axios from 'axios';\nimport { Logger } from '@aws-amplify/core';\nimport { byteLength, isFile } from '../common/StorageUtils';\nimport { AWSS3ProviderUploadErrorStrings } from '../common/StorageErrorStrings';\nimport { SET_CONTENT_LENGTH_HEADER, UPLOADS_STORAGE_KEY } from '../common/StorageConstants';\nvar logger = new Logger('AWSS3UploadTask');\nexport var AWSS3UploadTaskState;\n\n(function (AWSS3UploadTaskState) {\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"INIT\"] = 0] = \"INIT\";\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"IN_PROGRESS\"] = 1] = \"IN_PROGRESS\";\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"PAUSED\"] = 2] = \"PAUSED\";\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"CANCELLED\"] = 3] = \"CANCELLED\";\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"COMPLETED\"] = 4] = \"COMPLETED\";\n})(AWSS3UploadTaskState || (AWSS3UploadTaskState = {}));\n\nexport var TaskEvents;\n\n(function (TaskEvents) {\n  TaskEvents[\"CANCEL\"] = \"cancel\";\n  TaskEvents[\"UPLOAD_COMPLETE\"] = \"uploadComplete\";\n  TaskEvents[\"UPLOAD_PROGRESS\"] = \"uploadPartProgress\";\n  TaskEvents[\"ERROR\"] = \"error\";\n})(TaskEvents || (TaskEvents = {})); // maximum number of parts per upload request according the S3 spec,\n// see: https://docs.aws.amazon.com/AmazonS3/latest/userguide/qfacts.html\n\n\nvar MAX_PARTS = 10000; // 5MB in bytes\n\nvar PART_SIZE = 5 * 1024 * 1024;\nvar DEFAULT_QUEUE_SIZE = 4;\n\nfunction comparePartNumber(a, b) {\n  return a.PartNumber - b.PartNumber;\n}\n\nvar AWSS3UploadTask =\n/** @class */\nfunction () {\n  function AWSS3UploadTask(_a) {\n    var s3Client = _a.s3Client,\n        file = _a.file,\n        emitter = _a.emitter,\n        storage = _a.storage,\n        params = _a.params,\n        level = _a.level,\n        prefixPromise = _a.prefixPromise;\n    this.partSize = PART_SIZE;\n    this.queueSize = DEFAULT_QUEUE_SIZE;\n    this.inProgress = [];\n    this.completedParts = [];\n    this.queued = [];\n    this.bytesUploaded = 0;\n    this.totalBytes = 0;\n    this.state = AWSS3UploadTaskState.INIT;\n    this.prefixPromise = prefixPromise;\n    this.s3client = s3Client;\n    this.s3client.middlewareStack.remove(SET_CONTENT_LENGTH_HEADER);\n    this.storage = storage;\n    this.storageSync = Promise.resolve();\n\n    if (typeof this.storage['sync'] === 'function') {\n      this.storageSync = this.storage['sync']();\n    }\n\n    this.params = params;\n    this.file = file;\n    this.totalBytes = this.file.size;\n    this.bytesUploaded = 0;\n    this.emitter = emitter;\n    this.queued = [];\n    this.fileId = this._getFileId(level);\n\n    this._validateParams(); // event emitter will re-throw an error if an event emits an error unless there's a listener, attaching a no-op\n    // function to it unless user adds their own onError callback\n\n\n    this.emitter.on(TaskEvents.ERROR, function () {});\n  }\n\n  Object.defineProperty(AWSS3UploadTask.prototype, \"percent\", {\n    get: function () {\n      return this.bytesUploaded / this.totalBytes * 100;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AWSS3UploadTask.prototype, \"isInProgress\", {\n    get: function () {\n      return this.state === AWSS3UploadTaskState.IN_PROGRESS;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  AWSS3UploadTask.prototype._listSingleFile = function (_a) {\n    var key = _a.key,\n        bucket = _a.bucket;\n    return __awaiter(this, void 0, void 0, function () {\n      var listObjectRes, _b, Contents, prefix, obj;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.s3client.send(new ListObjectsV2Command({\n              Bucket: bucket,\n              Prefix: key\n            }))];\n\n          case 1:\n            listObjectRes = _c.sent();\n            _b = listObjectRes.Contents, Contents = _b === void 0 ? [] : _b;\n            return [4\n            /*yield*/\n            , this.prefixPromise];\n\n          case 2:\n            prefix = _c.sent();\n            obj = Contents.find(function (o) {\n              return o.Key === \"\" + prefix + key;\n            });\n            return [2\n            /*return*/\n            , obj];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._getFileId = function (level) {\n    // We should check if it's a File first because File is also instance of a Blob\n    if (isFile(this.file)) {\n      return [this.file.name, this.file.lastModified, this.file.size, this.file.type, this.params.Bucket, level, this.params.Key].join('-');\n    } else {\n      return [this.file.size, this.file.type, this.params.Bucket, level, this.params.Key].join('-');\n    }\n  };\n\n  AWSS3UploadTask.prototype._findCachedUploadParts = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var uploadRequests, cachedUploadFileData, listPartsOutput;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._listCachedUploadTasks()];\n\n          case 1:\n            uploadRequests = _a.sent();\n\n            if (Object.keys(uploadRequests).length === 0 || !Object.prototype.hasOwnProperty.call(uploadRequests, this.fileId)) {\n              return [2\n              /*return*/\n              , {\n                parts: [],\n                uploadId: null\n              }];\n            }\n\n            cachedUploadFileData = uploadRequests[this.fileId];\n            cachedUploadFileData.lastTouched = Date.now();\n            this.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n            return [4\n            /*yield*/\n            , this.s3client.send(new ListPartsCommand({\n              Bucket: this.params.Bucket,\n              Key: this.params.Key,\n              UploadId: cachedUploadFileData.uploadId\n            }))];\n\n          case 2:\n            listPartsOutput = _a.sent();\n            return [2\n            /*return*/\n            , {\n              parts: listPartsOutput.Parts || [],\n              uploadId: cachedUploadFileData.uploadId\n            }];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._emitEvent = function (event, payload) {\n    this.emitter.emit(event, payload);\n  };\n\n  AWSS3UploadTask.prototype._validateParams = function () {\n    if (this.file.size / this.partSize > MAX_PARTS) {\n      throw new Error(\"Too many parts. Number of parts is \" + this.file.size / this.partSize + \", maximum is \" + MAX_PARTS + \".\");\n    }\n  };\n\n  AWSS3UploadTask.prototype._listCachedUploadTasks = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var tasks;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.storageSync];\n\n          case 1:\n            _a.sent();\n\n            tasks = this.storage.getItem(UPLOADS_STORAGE_KEY) || '{}';\n            return [2\n            /*return*/\n            , JSON.parse(tasks)];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._cache = function (fileMetadata) {\n    return __awaiter(this, void 0, void 0, function () {\n      var uploadRequests;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._listCachedUploadTasks()];\n\n          case 1:\n            uploadRequests = _a.sent();\n            uploadRequests[this.fileId] = fileMetadata;\n            this.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._isCached = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _b = (_a = Object.prototype.hasOwnProperty).call;\n            return [4\n            /*yield*/\n            , this._listCachedUploadTasks()];\n\n          case 1:\n            return [2\n            /*return*/\n            , _b.apply(_a, [_c.sent(), this.fileId])];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._removeFromCache = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var uploadRequests;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._listCachedUploadTasks()];\n\n          case 1:\n            uploadRequests = _a.sent();\n            delete uploadRequests[this.fileId];\n            this.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._onPartUploadCompletion = function (_a) {\n    var eTag = _a.eTag,\n        partNumber = _a.partNumber,\n        chunk = _a.chunk;\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_b) {\n        this.completedParts.push({\n          ETag: eTag,\n          PartNumber: partNumber\n        });\n        this.bytesUploaded += byteLength(chunk);\n\n        this._emitEvent(TaskEvents.UPLOAD_PROGRESS, {\n          loaded: this.bytesUploaded,\n          total: this.totalBytes\n        }); // Remove the completed item from the inProgress array\n\n\n        this.inProgress = this.inProgress.filter(function (job) {\n          return job.uploadPartInput.PartNumber !== partNumber;\n        });\n        if (this.queued.length && this.state !== AWSS3UploadTaskState.PAUSED) this._startNextPart();\n        if (this._isDone()) this._completeUpload();\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._completeUpload = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var err_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.s3client.send(new CompleteMultipartUploadCommand({\n              Bucket: this.params.Bucket,\n              Key: this.params.Key,\n              UploadId: this.uploadId,\n              MultipartUpload: {\n                // Parts are not always completed in order, we need to manually sort them\n                Parts: this.completedParts.sort(comparePartNumber)\n              }\n            }))];\n\n          case 1:\n            _a.sent();\n\n            this._verifyFileSize();\n\n            this._emitEvent(TaskEvents.UPLOAD_COMPLETE, {\n              key: this.params.Bucket + \"/\" + this.params.Key\n            });\n\n            this._removeFromCache();\n\n            this.state = AWSS3UploadTaskState.COMPLETED;\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            err_1 = _a.sent();\n            logger.error('error completing upload', err_1);\n\n            this._emitEvent(TaskEvents.ERROR, err_1);\n\n            return [3\n            /*break*/\n            , 3];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._makeUploadPartRequest = function (input, cancelTokenSource) {\n    return __awaiter(this, void 0, void 0, function () {\n      var res, err_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.s3client.send(new UploadPartCommand(input), {\n              cancelTokenSource: cancelTokenSource\n            })];\n\n          case 1:\n            res = _a.sent();\n            return [4\n            /*yield*/\n            , this._onPartUploadCompletion({\n              eTag: res.ETag,\n              partNumber: input.PartNumber,\n              chunk: input.Body\n            })];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            err_2 = _a.sent();\n\n            if (this.state === AWSS3UploadTaskState.PAUSED) {\n              logger.log('upload paused');\n            } else if (this.state === AWSS3UploadTaskState.CANCELLED) {\n              logger.log('upload aborted');\n            } else {\n              logger.error('error starting next part of upload: ', err_2);\n            } // axios' cancel will also throw an error, however we don't need to emit an event in that case as it's an\n            // expected behavior\n\n\n            if (!axios.isCancel(err_2) && err_2.message !== AWSS3ProviderUploadErrorStrings.UPLOAD_PAUSED_MESSAGE) {\n              this._emitEvent(TaskEvents.ERROR, err_2);\n\n              this.pause();\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._startNextPart = function () {\n    if (this.queued.length > 0 && this.state !== AWSS3UploadTaskState.PAUSED) {\n      var cancelTokenSource = axios.CancelToken.source();\n      var nextPart = this.queued.shift();\n      this.inProgress.push({\n        uploadPartInput: nextPart,\n        s3Request: this._makeUploadPartRequest(nextPart, cancelTokenSource),\n        cancel: cancelTokenSource.cancel\n      });\n    }\n  };\n  /**\n   * Verify on S3 side that the file size matches the one on the client side.\n   *\n   * @async\n   * @throws throws an error if the file size does not match between local copy of the file and the file on s3.\n   */\n\n\n  AWSS3UploadTask.prototype._verifyFileSize = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var obj, valid;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._listSingleFile({\n              key: this.params.Key,\n              bucket: this.params.Bucket\n            })];\n\n          case 1:\n            obj = _a.sent();\n            valid = Boolean(obj && obj.Size === this.file.size);\n\n            if (!valid) {\n              throw new Error('File size does not match between local file and file on s3');\n            }\n\n            return [2\n            /*return*/\n            , valid];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._isDone = function () {\n    return !this.queued.length && !this.inProgress.length && this.bytesUploaded === this.totalBytes;\n  };\n\n  AWSS3UploadTask.prototype._createParts = function () {\n    var size = this.file.size;\n    var parts = [];\n\n    for (var bodyStart = 0; bodyStart < size;) {\n      var bodyEnd = Math.min(bodyStart + this.partSize, size);\n      parts.push({\n        Body: this.file.slice(bodyStart, bodyEnd),\n        Key: this.params.Key,\n        Bucket: this.params.Bucket,\n        PartNumber: parts.length + 1,\n        UploadId: this.uploadId\n      });\n      bodyStart += this.partSize;\n    }\n\n    return parts;\n  };\n\n  AWSS3UploadTask.prototype._initCachedUploadParts = function (cachedParts) {\n    this.bytesUploaded += cachedParts.reduce(function (acc, part) {\n      return acc + part.Size;\n    }, 0); // Find the set of part numbers that have already been uploaded\n\n    var uploadedPartNumSet = new Set(cachedParts.map(function (part) {\n      return part.PartNumber;\n    }));\n    this.queued = this.queued.filter(function (part) {\n      return !uploadedPartNumSet.has(part.PartNumber);\n    });\n    this.completedParts = cachedParts.map(function (part) {\n      return {\n        PartNumber: part.PartNumber,\n        ETag: part.ETag\n      };\n    });\n\n    this._emitEvent(TaskEvents.UPLOAD_PROGRESS, {\n      loaded: this.bytesUploaded,\n      total: this.totalBytes\n    });\n  };\n\n  AWSS3UploadTask.prototype._initMultipartUpload = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var res;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.s3client.send(new CreateMultipartUploadCommand(this.params))];\n\n          case 1:\n            res = _a.sent();\n\n            this._cache({\n              uploadId: res.UploadId,\n              lastTouched: Date.now(),\n              bucket: this.params.Bucket,\n              key: this.params.Key,\n              fileName: this.file instanceof File ? this.file.name : ''\n            });\n\n            return [2\n            /*return*/\n            , res.UploadId];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._initializeUploadTask = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, parts, uploadId, uploadId, err_3;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            this.state = AWSS3UploadTaskState.IN_PROGRESS;\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 7,, 8]);\n\n            return [4\n            /*yield*/\n            , this._isCached()];\n\n          case 2:\n            if (!_b.sent()) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , this._findCachedUploadParts()];\n\n          case 3:\n            _a = _b.sent(), parts = _a.parts, uploadId = _a.uploadId;\n            this.uploadId = uploadId;\n            this.queued = this._createParts();\n\n            this._initCachedUploadParts(parts);\n\n            this._startUpload();\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 4:\n            if (!!this.uploadId) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , this._initMultipartUpload()];\n\n          case 5:\n            uploadId = _b.sent();\n            this.uploadId = uploadId;\n            this.queued = this._createParts();\n\n            this._startUpload();\n\n            _b.label = 6;\n\n          case 6:\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            err_3 = _b.sent();\n\n            if (!axios.isCancel(err_3)) {\n              logger.error('Error initializing the upload task', err_3);\n            }\n\n            return [3\n            /*break*/\n            , 8];\n\n          case 8:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype.resume = function () {\n    if (this.state === AWSS3UploadTaskState.CANCELLED) {\n      logger.warn('This task has already been cancelled');\n    } else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n      logger.warn('This task has already been completed');\n    } else if (this.state === AWSS3UploadTaskState.IN_PROGRESS) {\n      logger.warn('Upload task already in progress'); // first time running resume, find any cached parts on s3 or start a new multipart upload request before\n      // starting the upload\n    } else if (!this.uploadId) {\n      this._initializeUploadTask();\n    } else {\n      this._startUpload();\n    }\n  };\n\n  AWSS3UploadTask.prototype._startUpload = function () {\n    this.state = AWSS3UploadTaskState.IN_PROGRESS;\n\n    for (var i = 0; i < this.queueSize; i++) {\n      this._startNextPart();\n    }\n  };\n\n  AWSS3UploadTask.prototype._cancel = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var err_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(this.state === AWSS3UploadTaskState.CANCELLED)) return [3\n            /*break*/\n            , 1];\n            logger.warn('This task has already been cancelled');\n            return [2\n            /*return*/\n            , false];\n\n          case 1:\n            if (!(this.state === AWSS3UploadTaskState.COMPLETED)) return [3\n            /*break*/\n            , 2];\n            logger.warn('This task has already been completed');\n            return [2\n            /*return*/\n            , false];\n\n          case 2:\n            this.pause();\n            this.queued = [];\n            this.completedParts = [];\n            this.bytesUploaded = 0;\n            this.state = AWSS3UploadTaskState.CANCELLED;\n            _a.label = 3;\n\n          case 3:\n            _a.trys.push([3, 6,, 7]);\n\n            return [4\n            /*yield*/\n            , this.s3client.send(new AbortMultipartUploadCommand({\n              Bucket: this.params.Bucket,\n              Key: this.params.Key,\n              UploadId: this.uploadId\n            }))];\n\n          case 4:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this._removeFromCache()];\n\n          case 5:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , true];\n\n          case 6:\n            err_4 = _a.sent();\n            logger.error('Error cancelling upload task', err_4);\n            return [2\n            /*return*/\n            , false];\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * pause this particular upload task\n   **/\n\n\n  AWSS3UploadTask.prototype.pause = function () {\n    var _a;\n\n    if (this.state === AWSS3UploadTaskState.CANCELLED) {\n      logger.warn('This task has already been cancelled');\n    } else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n      logger.warn('This task has already been completed');\n    } else if (this.state === AWSS3UploadTaskState.PAUSED) {\n      logger.warn('This task is already paused');\n    }\n\n    this.state = AWSS3UploadTaskState.PAUSED; // Use axios cancel token to abort the part request immediately\n    // Add the inProgress parts back to pending\n\n    var removedInProgressReq = this.inProgress.splice(0, this.inProgress.length);\n    removedInProgressReq.forEach(function (req) {\n      req.cancel(AWSS3ProviderUploadErrorStrings.UPLOAD_PAUSED_MESSAGE);\n    }); // Put all removed in progress parts back into the queue\n\n    (_a = this.queued).unshift.apply(_a, __spread(removedInProgressReq.map(function (req) {\n      return req.uploadPartInput;\n    })));\n  };\n\n  return AWSS3UploadTask;\n}();\n\nexport { AWSS3UploadTask };","map":{"version":3,"sources":["../../src/providers/AWSS3UploadTask.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nimport { UploadPartCommand, CompleteMultipartUploadCommand, AbortMultipartUploadCommand, ListPartsCommand, CreateMultipartUploadCommand, ListObjectsV2Command, } from '@aws-sdk/client-s3';\nimport axios from 'axios';\nimport { Logger } from '@aws-amplify/core';\nimport { byteLength, isFile } from '../common/StorageUtils';\nimport { AWSS3ProviderUploadErrorStrings } from '../common/StorageErrorStrings';\nimport { SET_CONTENT_LENGTH_HEADER, UPLOADS_STORAGE_KEY, } from '../common/StorageConstants';\nvar logger = new Logger('AWSS3UploadTask');\nexport var AWSS3UploadTaskState;\n(function (AWSS3UploadTaskState) {\n    AWSS3UploadTaskState[AWSS3UploadTaskState[\"INIT\"] = 0] = \"INIT\";\n    AWSS3UploadTaskState[AWSS3UploadTaskState[\"IN_PROGRESS\"] = 1] = \"IN_PROGRESS\";\n    AWSS3UploadTaskState[AWSS3UploadTaskState[\"PAUSED\"] = 2] = \"PAUSED\";\n    AWSS3UploadTaskState[AWSS3UploadTaskState[\"CANCELLED\"] = 3] = \"CANCELLED\";\n    AWSS3UploadTaskState[AWSS3UploadTaskState[\"COMPLETED\"] = 4] = \"COMPLETED\";\n})(AWSS3UploadTaskState || (AWSS3UploadTaskState = {}));\nexport var TaskEvents;\n(function (TaskEvents) {\n    TaskEvents[\"CANCEL\"] = \"cancel\";\n    TaskEvents[\"UPLOAD_COMPLETE\"] = \"uploadComplete\";\n    TaskEvents[\"UPLOAD_PROGRESS\"] = \"uploadPartProgress\";\n    TaskEvents[\"ERROR\"] = \"error\";\n})(TaskEvents || (TaskEvents = {}));\n// maximum number of parts per upload request according the S3 spec,\n// see: https://docs.aws.amazon.com/AmazonS3/latest/userguide/qfacts.html\nvar MAX_PARTS = 10000;\n// 5MB in bytes\nvar PART_SIZE = 5 * 1024 * 1024;\nvar DEFAULT_QUEUE_SIZE = 4;\nfunction comparePartNumber(a, b) {\n    return a.PartNumber - b.PartNumber;\n}\nvar AWSS3UploadTask = /** @class */ (function () {\n    function AWSS3UploadTask(_a) {\n        var s3Client = _a.s3Client, file = _a.file, emitter = _a.emitter, storage = _a.storage, params = _a.params, level = _a.level, prefixPromise = _a.prefixPromise;\n        this.partSize = PART_SIZE;\n        this.queueSize = DEFAULT_QUEUE_SIZE;\n        this.inProgress = [];\n        this.completedParts = [];\n        this.queued = [];\n        this.bytesUploaded = 0;\n        this.totalBytes = 0;\n        this.state = AWSS3UploadTaskState.INIT;\n        this.prefixPromise = prefixPromise;\n        this.s3client = s3Client;\n        this.s3client.middlewareStack.remove(SET_CONTENT_LENGTH_HEADER);\n        this.storage = storage;\n        this.storageSync = Promise.resolve();\n        if (typeof this.storage['sync'] === 'function') {\n            this.storageSync = this.storage['sync']();\n        }\n        this.params = params;\n        this.file = file;\n        this.totalBytes = this.file.size;\n        this.bytesUploaded = 0;\n        this.emitter = emitter;\n        this.queued = [];\n        this.fileId = this._getFileId(level);\n        this._validateParams();\n        // event emitter will re-throw an error if an event emits an error unless there's a listener, attaching a no-op\n        // function to it unless user adds their own onError callback\n        this.emitter.on(TaskEvents.ERROR, function () { });\n    }\n    Object.defineProperty(AWSS3UploadTask.prototype, \"percent\", {\n        get: function () {\n            return (this.bytesUploaded / this.totalBytes) * 100;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AWSS3UploadTask.prototype, \"isInProgress\", {\n        get: function () {\n            return this.state === AWSS3UploadTaskState.IN_PROGRESS;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AWSS3UploadTask.prototype._listSingleFile = function (_a) {\n        var key = _a.key, bucket = _a.bucket;\n        return __awaiter(this, void 0, void 0, function () {\n            var listObjectRes, _b, Contents, prefix, obj;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0: return [4 /*yield*/, this.s3client.send(new ListObjectsV2Command({\n                            Bucket: bucket,\n                            Prefix: key,\n                        }))];\n                    case 1:\n                        listObjectRes = _c.sent();\n                        _b = listObjectRes.Contents, Contents = _b === void 0 ? [] : _b;\n                        return [4 /*yield*/, this.prefixPromise];\n                    case 2:\n                        prefix = _c.sent();\n                        obj = Contents.find(function (o) { return o.Key === \"\" + prefix + key; });\n                        return [2 /*return*/, obj];\n                }\n            });\n        });\n    };\n    AWSS3UploadTask.prototype._getFileId = function (level) {\n        // We should check if it's a File first because File is also instance of a Blob\n        if (isFile(this.file)) {\n            return [\n                this.file.name,\n                this.file.lastModified,\n                this.file.size,\n                this.file.type,\n                this.params.Bucket,\n                level,\n                this.params.Key,\n            ].join('-');\n        }\n        else {\n            return [\n                this.file.size,\n                this.file.type,\n                this.params.Bucket,\n                level,\n                this.params.Key,\n            ].join('-');\n        }\n    };\n    AWSS3UploadTask.prototype._findCachedUploadParts = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var uploadRequests, cachedUploadFileData, listPartsOutput;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._listCachedUploadTasks()];\n                    case 1:\n                        uploadRequests = _a.sent();\n                        if (Object.keys(uploadRequests).length === 0 ||\n                            !Object.prototype.hasOwnProperty.call(uploadRequests, this.fileId)) {\n                            return [2 /*return*/, { parts: [], uploadId: null }];\n                        }\n                        cachedUploadFileData = uploadRequests[this.fileId];\n                        cachedUploadFileData.lastTouched = Date.now();\n                        this.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n                        return [4 /*yield*/, this.s3client.send(new ListPartsCommand({\n                                Bucket: this.params.Bucket,\n                                Key: this.params.Key,\n                                UploadId: cachedUploadFileData.uploadId,\n                            }))];\n                    case 2:\n                        listPartsOutput = _a.sent();\n                        return [2 /*return*/, {\n                                parts: listPartsOutput.Parts || [],\n                                uploadId: cachedUploadFileData.uploadId,\n                            }];\n                }\n            });\n        });\n    };\n    AWSS3UploadTask.prototype._emitEvent = function (event, payload) {\n        this.emitter.emit(event, payload);\n    };\n    AWSS3UploadTask.prototype._validateParams = function () {\n        if (this.file.size / this.partSize > MAX_PARTS) {\n            throw new Error(\"Too many parts. Number of parts is \" + this.file.size /\n                this.partSize + \", maximum is \" + MAX_PARTS + \".\");\n        }\n    };\n    AWSS3UploadTask.prototype._listCachedUploadTasks = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var tasks;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.storageSync];\n                    case 1:\n                        _a.sent();\n                        tasks = this.storage.getItem(UPLOADS_STORAGE_KEY) || '{}';\n                        return [2 /*return*/, JSON.parse(tasks)];\n                }\n            });\n        });\n    };\n    AWSS3UploadTask.prototype._cache = function (fileMetadata) {\n        return __awaiter(this, void 0, void 0, function () {\n            var uploadRequests;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._listCachedUploadTasks()];\n                    case 1:\n                        uploadRequests = _a.sent();\n                        uploadRequests[this.fileId] = fileMetadata;\n                        this.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AWSS3UploadTask.prototype._isCached = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        _b = (_a = Object.prototype.hasOwnProperty).call;\n                        return [4 /*yield*/, this._listCachedUploadTasks()];\n                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent(),\n                            this.fileId])];\n                }\n            });\n        });\n    };\n    AWSS3UploadTask.prototype._removeFromCache = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var uploadRequests;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._listCachedUploadTasks()];\n                    case 1:\n                        uploadRequests = _a.sent();\n                        delete uploadRequests[this.fileId];\n                        this.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AWSS3UploadTask.prototype._onPartUploadCompletion = function (_a) {\n        var eTag = _a.eTag, partNumber = _a.partNumber, chunk = _a.chunk;\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_b) {\n                this.completedParts.push({\n                    ETag: eTag,\n                    PartNumber: partNumber,\n                });\n                this.bytesUploaded += byteLength(chunk);\n                this._emitEvent(TaskEvents.UPLOAD_PROGRESS, {\n                    loaded: this.bytesUploaded,\n                    total: this.totalBytes,\n                });\n                // Remove the completed item from the inProgress array\n                this.inProgress = this.inProgress.filter(function (job) { return job.uploadPartInput.PartNumber !== partNumber; });\n                if (this.queued.length && this.state !== AWSS3UploadTaskState.PAUSED)\n                    this._startNextPart();\n                if (this._isDone())\n                    this._completeUpload();\n                return [2 /*return*/];\n            });\n        });\n    };\n    AWSS3UploadTask.prototype._completeUpload = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var err_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.s3client.send(new CompleteMultipartUploadCommand({\n                                Bucket: this.params.Bucket,\n                                Key: this.params.Key,\n                                UploadId: this.uploadId,\n                                MultipartUpload: {\n                                    // Parts are not always completed in order, we need to manually sort them\n                                    Parts: this.completedParts.sort(comparePartNumber),\n                                },\n                            }))];\n                    case 1:\n                        _a.sent();\n                        this._verifyFileSize();\n                        this._emitEvent(TaskEvents.UPLOAD_COMPLETE, {\n                            key: this.params.Bucket + \"/\" + this.params.Key,\n                        });\n                        this._removeFromCache();\n                        this.state = AWSS3UploadTaskState.COMPLETED;\n                        return [3 /*break*/, 3];\n                    case 2:\n                        err_1 = _a.sent();\n                        logger.error('error completing upload', err_1);\n                        this._emitEvent(TaskEvents.ERROR, err_1);\n                        return [3 /*break*/, 3];\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AWSS3UploadTask.prototype._makeUploadPartRequest = function (input, cancelTokenSource) {\n        return __awaiter(this, void 0, void 0, function () {\n            var res, err_2;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 3, , 4]);\n                        return [4 /*yield*/, this.s3client.send(new UploadPartCommand(input), {\n                                cancelTokenSource: cancelTokenSource,\n                            })];\n                    case 1:\n                        res = _a.sent();\n                        return [4 /*yield*/, this._onPartUploadCompletion({\n                                eTag: res.ETag,\n                                partNumber: input.PartNumber,\n                                chunk: input.Body,\n                            })];\n                    case 2:\n                        _a.sent();\n                        return [3 /*break*/, 4];\n                    case 3:\n                        err_2 = _a.sent();\n                        if (this.state === AWSS3UploadTaskState.PAUSED) {\n                            logger.log('upload paused');\n                        }\n                        else if (this.state === AWSS3UploadTaskState.CANCELLED) {\n                            logger.log('upload aborted');\n                        }\n                        else {\n                            logger.error('error starting next part of upload: ', err_2);\n                        }\n                        // axios' cancel will also throw an error, however we don't need to emit an event in that case as it's an\n                        // expected behavior\n                        if (!axios.isCancel(err_2) &&\n                            err_2.message !== AWSS3ProviderUploadErrorStrings.UPLOAD_PAUSED_MESSAGE) {\n                            this._emitEvent(TaskEvents.ERROR, err_2);\n                            this.pause();\n                        }\n                        return [3 /*break*/, 4];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AWSS3UploadTask.prototype._startNextPart = function () {\n        if (this.queued.length > 0 && this.state !== AWSS3UploadTaskState.PAUSED) {\n            var cancelTokenSource = axios.CancelToken.source();\n            var nextPart = this.queued.shift();\n            this.inProgress.push({\n                uploadPartInput: nextPart,\n                s3Request: this._makeUploadPartRequest(nextPart, cancelTokenSource),\n                cancel: cancelTokenSource.cancel,\n            });\n        }\n    };\n    /**\n     * Verify on S3 side that the file size matches the one on the client side.\n     *\n     * @async\n     * @throws throws an error if the file size does not match between local copy of the file and the file on s3.\n     */\n    AWSS3UploadTask.prototype._verifyFileSize = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var obj, valid;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._listSingleFile({\n                            key: this.params.Key,\n                            bucket: this.params.Bucket,\n                        })];\n                    case 1:\n                        obj = _a.sent();\n                        valid = Boolean(obj && obj.Size === this.file.size);\n                        if (!valid) {\n                            throw new Error('File size does not match between local file and file on s3');\n                        }\n                        return [2 /*return*/, valid];\n                }\n            });\n        });\n    };\n    AWSS3UploadTask.prototype._isDone = function () {\n        return (!this.queued.length &&\n            !this.inProgress.length &&\n            this.bytesUploaded === this.totalBytes);\n    };\n    AWSS3UploadTask.prototype._createParts = function () {\n        var size = this.file.size;\n        var parts = [];\n        for (var bodyStart = 0; bodyStart < size;) {\n            var bodyEnd = Math.min(bodyStart + this.partSize, size);\n            parts.push({\n                Body: this.file.slice(bodyStart, bodyEnd),\n                Key: this.params.Key,\n                Bucket: this.params.Bucket,\n                PartNumber: parts.length + 1,\n                UploadId: this.uploadId,\n            });\n            bodyStart += this.partSize;\n        }\n        return parts;\n    };\n    AWSS3UploadTask.prototype._initCachedUploadParts = function (cachedParts) {\n        this.bytesUploaded += cachedParts.reduce(function (acc, part) { return acc + part.Size; }, 0);\n        // Find the set of part numbers that have already been uploaded\n        var uploadedPartNumSet = new Set(cachedParts.map(function (part) { return part.PartNumber; }));\n        this.queued = this.queued.filter(function (part) { return !uploadedPartNumSet.has(part.PartNumber); });\n        this.completedParts = cachedParts.map(function (part) { return ({\n            PartNumber: part.PartNumber,\n            ETag: part.ETag,\n        }); });\n        this._emitEvent(TaskEvents.UPLOAD_PROGRESS, {\n            loaded: this.bytesUploaded,\n            total: this.totalBytes,\n        });\n    };\n    AWSS3UploadTask.prototype._initMultipartUpload = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var res;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.s3client.send(new CreateMultipartUploadCommand(this.params))];\n                    case 1:\n                        res = _a.sent();\n                        this._cache({\n                            uploadId: res.UploadId,\n                            lastTouched: Date.now(),\n                            bucket: this.params.Bucket,\n                            key: this.params.Key,\n                            fileName: this.file instanceof File ? this.file.name : '',\n                        });\n                        return [2 /*return*/, res.UploadId];\n                }\n            });\n        });\n    };\n    AWSS3UploadTask.prototype._initializeUploadTask = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, parts, uploadId, uploadId, err_3;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        this.state = AWSS3UploadTaskState.IN_PROGRESS;\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 7, , 8]);\n                        return [4 /*yield*/, this._isCached()];\n                    case 2:\n                        if (!_b.sent()) return [3 /*break*/, 4];\n                        return [4 /*yield*/, this._findCachedUploadParts()];\n                    case 3:\n                        _a = _b.sent(), parts = _a.parts, uploadId = _a.uploadId;\n                        this.uploadId = uploadId;\n                        this.queued = this._createParts();\n                        this._initCachedUploadParts(parts);\n                        this._startUpload();\n                        return [3 /*break*/, 6];\n                    case 4:\n                        if (!!this.uploadId) return [3 /*break*/, 6];\n                        return [4 /*yield*/, this._initMultipartUpload()];\n                    case 5:\n                        uploadId = _b.sent();\n                        this.uploadId = uploadId;\n                        this.queued = this._createParts();\n                        this._startUpload();\n                        _b.label = 6;\n                    case 6: return [3 /*break*/, 8];\n                    case 7:\n                        err_3 = _b.sent();\n                        if (!axios.isCancel(err_3)) {\n                            logger.error('Error initializing the upload task', err_3);\n                        }\n                        return [3 /*break*/, 8];\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AWSS3UploadTask.prototype.resume = function () {\n        if (this.state === AWSS3UploadTaskState.CANCELLED) {\n            logger.warn('This task has already been cancelled');\n        }\n        else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n            logger.warn('This task has already been completed');\n        }\n        else if (this.state === AWSS3UploadTaskState.IN_PROGRESS) {\n            logger.warn('Upload task already in progress');\n            // first time running resume, find any cached parts on s3 or start a new multipart upload request before\n            // starting the upload\n        }\n        else if (!this.uploadId) {\n            this._initializeUploadTask();\n        }\n        else {\n            this._startUpload();\n        }\n    };\n    AWSS3UploadTask.prototype._startUpload = function () {\n        this.state = AWSS3UploadTaskState.IN_PROGRESS;\n        for (var i = 0; i < this.queueSize; i++) {\n            this._startNextPart();\n        }\n    };\n    AWSS3UploadTask.prototype._cancel = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var err_4;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this.state === AWSS3UploadTaskState.CANCELLED)) return [3 /*break*/, 1];\n                        logger.warn('This task has already been cancelled');\n                        return [2 /*return*/, false];\n                    case 1:\n                        if (!(this.state === AWSS3UploadTaskState.COMPLETED)) return [3 /*break*/, 2];\n                        logger.warn('This task has already been completed');\n                        return [2 /*return*/, false];\n                    case 2:\n                        this.pause();\n                        this.queued = [];\n                        this.completedParts = [];\n                        this.bytesUploaded = 0;\n                        this.state = AWSS3UploadTaskState.CANCELLED;\n                        _a.label = 3;\n                    case 3:\n                        _a.trys.push([3, 6, , 7]);\n                        return [4 /*yield*/, this.s3client.send(new AbortMultipartUploadCommand({\n                                Bucket: this.params.Bucket,\n                                Key: this.params.Key,\n                                UploadId: this.uploadId,\n                            }))];\n                    case 4:\n                        _a.sent();\n                        return [4 /*yield*/, this._removeFromCache()];\n                    case 5:\n                        _a.sent();\n                        return [2 /*return*/, true];\n                    case 6:\n                        err_4 = _a.sent();\n                        logger.error('Error cancelling upload task', err_4);\n                        return [2 /*return*/, false];\n                    case 7: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * pause this particular upload task\n     **/\n    AWSS3UploadTask.prototype.pause = function () {\n        var _a;\n        if (this.state === AWSS3UploadTaskState.CANCELLED) {\n            logger.warn('This task has already been cancelled');\n        }\n        else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n            logger.warn('This task has already been completed');\n        }\n        else if (this.state === AWSS3UploadTaskState.PAUSED) {\n            logger.warn('This task is already paused');\n        }\n        this.state = AWSS3UploadTaskState.PAUSED;\n        // Use axios cancel token to abort the part request immediately\n        // Add the inProgress parts back to pending\n        var removedInProgressReq = this.inProgress.splice(0, this.inProgress.length);\n        removedInProgressReq.forEach(function (req) {\n            req.cancel(AWSS3ProviderUploadErrorStrings.UPLOAD_PAUSED_MESSAGE);\n        });\n        // Put all removed in progress parts back into the queue\n        (_a = this.queued).unshift.apply(_a, __spread(removedInProgressReq.map(function (req) { return req.uploadPartInput; })));\n    };\n    return AWSS3UploadTask;\n}());\nexport { AWSS3UploadTask };\n//# sourceMappingURL=AWSS3UploadTask.js.map"]},"metadata":{},"sourceType":"module"}