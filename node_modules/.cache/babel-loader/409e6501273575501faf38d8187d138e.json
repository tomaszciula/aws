{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { isThrottlingError } from \"@aws-sdk/service-error-classification\";\n\nvar DefaultRateLimiter =\n/** @class */\nfunction () {\n  function DefaultRateLimiter(options) {\n    var _a, _b, _c, _d, _e; // Pre-set state variables\n\n\n    this.currentCapacity = 0;\n    this.enabled = false;\n    this.lastMaxRate = 0;\n    this.measuredTxRate = 0;\n    this.requestCount = 0;\n    this.lastTimestamp = 0;\n    this.timeWindow = 0;\n    this.beta = (_a = options === null || options === void 0 ? void 0 : options.beta) !== null && _a !== void 0 ? _a : 0.7;\n    this.minCapacity = (_b = options === null || options === void 0 ? void 0 : options.minCapacity) !== null && _b !== void 0 ? _b : 1;\n    this.minFillRate = (_c = options === null || options === void 0 ? void 0 : options.minFillRate) !== null && _c !== void 0 ? _c : 0.5;\n    this.scaleConstant = (_d = options === null || options === void 0 ? void 0 : options.scaleConstant) !== null && _d !== void 0 ? _d : 0.4;\n    this.smooth = (_e = options === null || options === void 0 ? void 0 : options.smooth) !== null && _e !== void 0 ? _e : 0.8;\n    var currentTimeInSeconds = this.getCurrentTimeInSeconds();\n    this.lastThrottleTime = currentTimeInSeconds;\n    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());\n    this.fillRate = this.minFillRate;\n    this.maxCapacity = this.minCapacity;\n  }\n\n  DefaultRateLimiter.prototype.getCurrentTimeInSeconds = function () {\n    return Date.now() / 1000;\n  };\n\n  DefaultRateLimiter.prototype.getSendToken = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.acquireTokenBucket(1)];\n      });\n    });\n  };\n\n  DefaultRateLimiter.prototype.acquireTokenBucket = function (amount) {\n    return __awaiter(this, void 0, void 0, function () {\n      var delay_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Client side throttling is not enabled until we see a throttling error.\n            if (!this.enabled) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            this.refillTokenBucket();\n            if (!(amount > this.currentCapacity)) return [3\n            /*break*/\n            , 2];\n            delay_1 = (amount - this.currentCapacity) / this.fillRate * 1000;\n            return [4\n            /*yield*/\n            , new Promise(function (resolve) {\n              return setTimeout(resolve, delay_1);\n            })];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            this.currentCapacity = this.currentCapacity - amount;\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  DefaultRateLimiter.prototype.refillTokenBucket = function () {\n    var timestamp = this.getCurrentTimeInSeconds();\n\n    if (!this.lastTimestamp) {\n      this.lastTimestamp = timestamp;\n      return;\n    }\n\n    var fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;\n    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);\n    this.lastTimestamp = timestamp;\n  };\n\n  DefaultRateLimiter.prototype.updateClientSendingRate = function (response) {\n    var calculatedRate;\n    this.updateMeasuredRate();\n\n    if (isThrottlingError(response)) {\n      var rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);\n      this.lastMaxRate = rateToUse;\n      this.calculateTimeWindow();\n      this.lastThrottleTime = this.getCurrentTimeInSeconds();\n      calculatedRate = this.cubicThrottle(rateToUse);\n      this.enableTokenBucket();\n    } else {\n      this.calculateTimeWindow();\n      calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());\n    }\n\n    var newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);\n    this.updateTokenBucketRate(newRate);\n  };\n\n  DefaultRateLimiter.prototype.calculateTimeWindow = function () {\n    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));\n  };\n\n  DefaultRateLimiter.prototype.cubicThrottle = function (rateToUse) {\n    return this.getPrecise(rateToUse * this.beta);\n  };\n\n  DefaultRateLimiter.prototype.cubicSuccess = function (timestamp) {\n    return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);\n  };\n\n  DefaultRateLimiter.prototype.enableTokenBucket = function () {\n    this.enabled = true;\n  };\n\n  DefaultRateLimiter.prototype.updateTokenBucketRate = function (newRate) {\n    // Refill based on our current rate before we update to the new fill rate.\n    this.refillTokenBucket();\n    this.fillRate = Math.max(newRate, this.minFillRate);\n    this.maxCapacity = Math.max(newRate, this.minCapacity); // When we scale down we can't have a current capacity that exceeds our maxCapacity.\n\n    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);\n  };\n\n  DefaultRateLimiter.prototype.updateMeasuredRate = function () {\n    var t = this.getCurrentTimeInSeconds();\n    var timeBucket = Math.floor(t * 2) / 2;\n    this.requestCount++;\n\n    if (timeBucket > this.lastTxRateBucket) {\n      var currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);\n      this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));\n      this.requestCount = 0;\n      this.lastTxRateBucket = timeBucket;\n    }\n  };\n\n  DefaultRateLimiter.prototype.getPrecise = function (num) {\n    return parseFloat(num.toFixed(8));\n  };\n\n  return DefaultRateLimiter;\n}();\n\nexport { DefaultRateLimiter };","map":{"version":3,"sources":["../../src/DefaultRateLimiter.ts"],"names":[],"mappings":"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","sourcesContent":["import { isThrottlingError } from \"@aws-sdk/service-error-classification\";\n\nimport { RateLimiter } from \"./types\";\n\nexport interface DefaultRateLimiterOptions {\n  beta?: number;\n  minCapacity?: number;\n  minFillRate?: number;\n  scaleConstant?: number;\n  smooth?: number;\n}\n\nexport class DefaultRateLimiter implements RateLimiter {\n  // User configurable constants\n  private beta: number;\n  private minCapacity: number;\n  private minFillRate: number;\n  private scaleConstant: number;\n  private smooth: number;\n\n  // Pre-set state variables\n  private currentCapacity = 0;\n  private enabled = false;\n  private lastMaxRate = 0;\n  private measuredTxRate = 0;\n  private requestCount = 0;\n\n  // Other state variables\n  private fillRate: number;\n  private lastThrottleTime: number;\n  private lastTimestamp = 0;\n  private lastTxRateBucket: number;\n  private maxCapacity: number;\n  private timeWindow = 0;\n\n  constructor(options?: DefaultRateLimiterOptions) {\n    this.beta = options?.beta ?? 0.7;\n    this.minCapacity = options?.minCapacity ?? 1;\n    this.minFillRate = options?.minFillRate ?? 0.5;\n    this.scaleConstant = options?.scaleConstant ?? 0.4;\n    this.smooth = options?.smooth ?? 0.8;\n\n    const currentTimeInSeconds = this.getCurrentTimeInSeconds();\n    this.lastThrottleTime = currentTimeInSeconds;\n    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());\n\n    this.fillRate = this.minFillRate;\n    this.maxCapacity = this.minCapacity;\n  }\n\n  private getCurrentTimeInSeconds() {\n    return Date.now() / 1000;\n  }\n\n  public async getSendToken() {\n    return this.acquireTokenBucket(1);\n  }\n\n  private async acquireTokenBucket(amount: number) {\n    // Client side throttling is not enabled until we see a throttling error.\n    if (!this.enabled) {\n      return;\n    }\n\n    this.refillTokenBucket();\n    if (amount > this.currentCapacity) {\n      const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;\n      await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n    this.currentCapacity = this.currentCapacity - amount;\n  }\n\n  private refillTokenBucket() {\n    const timestamp = this.getCurrentTimeInSeconds();\n    if (!this.lastTimestamp) {\n      this.lastTimestamp = timestamp;\n      return;\n    }\n\n    const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;\n    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);\n    this.lastTimestamp = timestamp;\n  }\n\n  public updateClientSendingRate(response: any) {\n    let calculatedRate: number;\n    this.updateMeasuredRate();\n\n    if (isThrottlingError(response)) {\n      const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);\n      this.lastMaxRate = rateToUse;\n      this.calculateTimeWindow();\n      this.lastThrottleTime = this.getCurrentTimeInSeconds();\n      calculatedRate = this.cubicThrottle(rateToUse);\n      this.enableTokenBucket();\n    } else {\n      this.calculateTimeWindow();\n      calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());\n    }\n\n    const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);\n    this.updateTokenBucketRate(newRate);\n  }\n\n  private calculateTimeWindow() {\n    this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));\n  }\n\n  private cubicThrottle(rateToUse: number) {\n    return this.getPrecise(rateToUse * this.beta);\n  }\n\n  private cubicSuccess(timestamp: number) {\n    return this.getPrecise(\n      this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate\n    );\n  }\n\n  private enableTokenBucket() {\n    this.enabled = true;\n  }\n\n  private updateTokenBucketRate(newRate: number) {\n    // Refill based on our current rate before we update to the new fill rate.\n    this.refillTokenBucket();\n\n    this.fillRate = Math.max(newRate, this.minFillRate);\n    this.maxCapacity = Math.max(newRate, this.minCapacity);\n\n    // When we scale down we can't have a current capacity that exceeds our maxCapacity.\n    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);\n  }\n\n  private updateMeasuredRate() {\n    const t = this.getCurrentTimeInSeconds();\n    const timeBucket = Math.floor(t * 2) / 2;\n    this.requestCount++;\n\n    if (timeBucket > this.lastTxRateBucket) {\n      const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);\n      this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));\n      this.requestCount = 0;\n      this.lastTxRateBucket = timeBucket;\n    }\n  }\n\n  private getPrecise(num: number) {\n    return parseFloat(num.toFixed(8));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}