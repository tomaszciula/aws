{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { HttpRequest } from \"@aws-sdk/protocol-http\";\nimport { isThrottlingError } from \"@aws-sdk/service-error-classification\";\nimport { v4 } from \"uuid\";\nimport { DEFAULT_MAX_ATTEMPTS, RETRY_MODES } from \"./config\";\nimport { DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, INVOCATION_ID_HEADER, REQUEST_HEADER, THROTTLING_RETRY_DELAY_BASE } from \"./constants\";\nimport { getDefaultRetryQuota } from \"./defaultRetryQuota\";\nimport { defaultDelayDecider } from \"./delayDecider\";\nimport { defaultRetryDecider } from \"./retryDecider\";\n\nvar StandardRetryStrategy =\n/** @class */\nfunction () {\n  function StandardRetryStrategy(maxAttemptsProvider, options) {\n    var _a, _b, _c;\n\n    this.maxAttemptsProvider = maxAttemptsProvider;\n    this.mode = RETRY_MODES.STANDARD;\n    this.retryDecider = (_a = options === null || options === void 0 ? void 0 : options.retryDecider) !== null && _a !== void 0 ? _a : defaultRetryDecider;\n    this.delayDecider = (_b = options === null || options === void 0 ? void 0 : options.delayDecider) !== null && _b !== void 0 ? _b : defaultDelayDecider;\n    this.retryQuota = (_c = options === null || options === void 0 ? void 0 : options.retryQuota) !== null && _c !== void 0 ? _c : getDefaultRetryQuota(INITIAL_RETRY_TOKENS);\n  }\n\n  StandardRetryStrategy.prototype.shouldRetry = function (error, attempts, maxAttempts) {\n    return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);\n  };\n\n  StandardRetryStrategy.prototype.getMaxAttempts = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var maxAttempts, error_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.maxAttemptsProvider()];\n\n          case 1:\n            maxAttempts = _a.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            error_1 = _a.sent();\n            maxAttempts = DEFAULT_MAX_ATTEMPTS;\n            return [3\n            /*break*/\n            , 3];\n\n          case 3:\n            return [2\n            /*return*/\n            , maxAttempts];\n        }\n      });\n    });\n  };\n\n  StandardRetryStrategy.prototype.retry = function (next, args, options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var retryTokenAmount, attempts, totalDelay, maxAttempts, request, _loop_1, this_1, state_1;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            attempts = 0;\n            totalDelay = 0;\n            return [4\n            /*yield*/\n            , this.getMaxAttempts()];\n\n          case 1:\n            maxAttempts = _a.sent();\n            request = args.request;\n\n            if (HttpRequest.isInstance(request)) {\n              request.headers[INVOCATION_ID_HEADER] = v4();\n            }\n\n            _loop_1 = function () {\n              var _b, response, output, e_1, err, delay_1;\n\n              return __generator(this, function (_c) {\n                switch (_c.label) {\n                  case 0:\n                    _c.trys.push([0, 4,, 7]);\n\n                    if (HttpRequest.isInstance(request)) {\n                      request.headers[REQUEST_HEADER] = \"attempt=\" + (attempts + 1) + \"; max=\" + maxAttempts;\n                    }\n\n                    if (!(options === null || options === void 0 ? void 0 : options.beforeRequest)) return [3\n                    /*break*/\n                    , 2];\n                    return [4\n                    /*yield*/\n                    , options.beforeRequest()];\n\n                  case 1:\n                    _c.sent();\n\n                    _c.label = 2;\n\n                  case 2:\n                    return [4\n                    /*yield*/\n                    , next(args)];\n\n                  case 3:\n                    _b = _c.sent(), response = _b.response, output = _b.output;\n\n                    if (options === null || options === void 0 ? void 0 : options.afterRequest) {\n                      options.afterRequest(response);\n                    }\n\n                    this_1.retryQuota.releaseRetryTokens(retryTokenAmount);\n                    output.$metadata.attempts = attempts + 1;\n                    output.$metadata.totalRetryDelay = totalDelay;\n                    return [2\n                    /*return*/\n                    , {\n                      value: {\n                        response: response,\n                        output: output\n                      }\n                    }];\n\n                  case 4:\n                    e_1 = _c.sent();\n                    err = asSdkError(e_1);\n                    attempts++;\n                    if (!this_1.shouldRetry(err, attempts, maxAttempts)) return [3\n                    /*break*/\n                    , 6];\n                    retryTokenAmount = this_1.retryQuota.retrieveRetryTokens(err);\n                    delay_1 = this_1.delayDecider(isThrottlingError(err) ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE, attempts);\n                    totalDelay += delay_1;\n                    return [4\n                    /*yield*/\n                    , new Promise(function (resolve) {\n                      return setTimeout(resolve, delay_1);\n                    })];\n\n                  case 5:\n                    _c.sent();\n\n                    return [2\n                    /*return*/\n                    , \"continue\"];\n\n                  case 6:\n                    if (!err.$metadata) {\n                      err.$metadata = {};\n                    }\n\n                    err.$metadata.attempts = attempts;\n                    err.$metadata.totalRetryDelay = totalDelay;\n                    throw err;\n\n                  case 7:\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            };\n\n            this_1 = this;\n            _a.label = 2;\n\n          case 2:\n            if (!true) return [3\n            /*break*/\n            , 4];\n            return [5\n            /*yield**/\n            , _loop_1()];\n\n          case 3:\n            state_1 = _a.sent();\n            if (typeof state_1 === \"object\") return [2\n            /*return*/\n            , state_1.value];\n            return [3\n            /*break*/\n            , 2];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return StandardRetryStrategy;\n}();\n\nexport { StandardRetryStrategy };\n\nvar asSdkError = function (error) {\n  if (error instanceof Error) return error;\n  if (error instanceof Object) return Object.assign(new Error(), error);\n  if (typeof error === \"string\") return new Error(error);\n  return new Error(\"AWS SDK error wrapper for \" + error);\n};","map":{"version":3,"sources":["../../src/StandardRetryStrategy.ts"],"names":[],"mappings":";AAAA,SAAS,WAAT,QAA4B,wBAA5B;AACA,SAAS,iBAAT,QAAkC,uCAAlC;AAGA,SAAS,EAAT,QAAmB,MAAnB;AAEA,SAAS,oBAAT,EAA+B,WAA/B,QAAkD,UAAlD;AACA,SACE,wBADF,EAEE,oBAFF,EAGE,oBAHF,EAIE,cAJF,EAKE,2BALF,QAMO,aANP;AAOA,SAAS,oBAAT,QAAqC,qBAArC;AACA,SAAS,mBAAT,QAAoC,gBAApC;AACA,SAAS,mBAAT,QAAoC,gBAApC;;AAYA,IAAA,qBAAA;AAAA;AAAA,YAAA;AAME,WAAA,qBAAA,CAA6B,mBAA7B,EAAoE,OAApE,EAA0G;;;AAA7E,SAAA,mBAAA,GAAA,mBAAA;AAFtB,SAAA,IAAA,GAAe,WAAW,CAAC,QAA3B;AAGL,SAAK,YAAL,GAAoB,CAAA,EAAA,GAAA,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,YAAT,MAAqB,IAArB,IAAqB,EAAA,KAAA,KAAA,CAArB,GAAqB,EAArB,GAAyB,mBAA7C;AACA,SAAK,YAAL,GAAoB,CAAA,EAAA,GAAA,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,YAAT,MAAqB,IAArB,IAAqB,EAAA,KAAA,KAAA,CAArB,GAAqB,EAArB,GAAyB,mBAA7C;AACA,SAAK,UAAL,GAAkB,CAAA,EAAA,GAAA,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,UAAT,MAAmB,IAAnB,IAAmB,EAAA,KAAA,KAAA,CAAnB,GAAmB,EAAnB,GAAuB,oBAAoB,CAAC,oBAAD,CAA7D;AACD;;AAEO,EAAA,qBAAA,CAAA,SAAA,CAAA,WAAA,GAAR,UAAoB,KAApB,EAAqC,QAArC,EAAuD,WAAvD,EAA0E;AACxE,WAAO,QAAQ,GAAG,WAAX,IAA0B,KAAK,YAAL,CAAkB,KAAlB,CAA1B,IAAsD,KAAK,UAAL,CAAgB,cAAhB,CAA+B,KAA/B,CAA7D;AACD,GAFO;;AAIM,EAAA,qBAAA,CAAA,SAAA,CAAA,cAAA,GAAd,YAAA;;;;;;;;AAGkB,mBAAA,CAAA;AAAA;AAAA,cAAM,KAAK,mBAAL,EAAN,CAAA;;;AAAd,YAAA,WAAW,GAAG,EAAA,CAAA,IAAA,EAAd;;;;;;;AAEA,YAAA,WAAW,GAAG,oBAAd;;;;;;AAEF,mBAAA,CAAA;AAAA;AAAA,cAAO,WAAP,CAAA;;;;AACD,GARa;;AAUR,EAAA,qBAAA,CAAA,SAAA,CAAA,KAAA,GAAN,UACE,IADF,EAEE,IAFF,EAGE,OAHF,EAMG;;;;;;;AAGG,YAAA,QAAQ,GAAG,CAAX;AACA,YAAA,UAAU,GAAG,CAAb;AAEgB,mBAAA,CAAA;AAAA;AAAA,cAAM,KAAK,cAAL,EAAN,CAAA;;;AAAd,YAAA,WAAW,GAAG,EAAA,CAAA,IAAA,EAAd;AAEE,YAAA,OAAO,GAAK,IAAI,CAAT,OAAP;;AACR,gBAAI,WAAW,CAAC,UAAZ,CAAuB,OAAvB,CAAJ,EAAqC;AACnC,cAAA,OAAO,CAAC,OAAR,CAAgB,oBAAhB,IAAwC,EAAE,EAA1C;AACD;;;;;;;;;;AAIG,wBAAI,WAAW,CAAC,UAAZ,CAAuB,OAAvB,CAAJ,EAAqC;AACnC,sBAAA,OAAO,CAAC,OAAR,CAAgB,cAAhB,IAAkC,cAAW,QAAQ,GAAG,CAAtB,IAAuB,QAAvB,GAAgC,WAAlE;AACD;;wBAEG,EAAA,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,aAAT,C,EAAA,OAAA,CAAA;AAAA;AAAA,sBAAA,CAAA,CAAA;AACF,2BAAA,CAAA;AAAA;AAAA,sBAAM,OAAO,CAAC,aAAR,EAAN,CAAA;;;AAAA,oBAAA,EAAA,CAAA,IAAA;;;;;AAE2B,2BAAA,CAAA;AAAA;AAAA,sBAAM,IAAI,CAAC,IAAD,CAAV,CAAA;;;AAAvB,oBAAA,EAAA,GAAuB,EAAA,CAAA,IAAA,EAAvB,EAAE,QAAQ,GAAA,EAAA,CAAA,QAAV,EAAY,MAAM,GAAA,EAAA,CAAA,MAAlB;;AACN,wBAAI,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,YAAb,EAA2B;AACzB,sBAAA,OAAO,CAAC,YAAR,CAAqB,QAArB;AACD;;AAED,oBAAA,MAAA,CAAK,UAAL,CAAgB,kBAAhB,CAAmC,gBAAnC;AACA,oBAAA,MAAM,CAAC,SAAP,CAAiB,QAAjB,GAA4B,QAAQ,GAAG,CAAvC;AACA,oBAAA,MAAM,CAAC,SAAP,CAAiB,eAAjB,GAAmC,UAAnC;;;;6BAEO;AAAE,wBAAA,QAAQ,EAAA,QAAV;AAAY,wBAAA,MAAM,EAAA;AAAlB;;;;;AAED,oBAAA,GAAG,GAAG,UAAU,CAAC,GAAD,CAAhB;AACN,oBAAA,QAAQ;yBACJ,MAAA,CAAK,WAAL,CAAiB,GAAjB,EAAkC,QAAlC,EAA4C,WAA5C,C,EAAA,OAAA,CAAA;AAAA;AAAA,sBAAA,CAAA,CAAA;AACF,oBAAA,gBAAgB,GAAG,MAAA,CAAK,UAAL,CAAgB,mBAAhB,CAAoC,GAApC,CAAnB;AACM,oBAAA,OAAA,GAAQ,MAAA,CAAK,YAAL,CACZ,iBAAiB,CAAC,GAAD,CAAjB,GAAyB,2BAAzB,GAAuD,wBAD3C,EAEZ,QAFY,CAAR;AAIN,oBAAA,UAAU,IAAI,OAAd;AAEA,2BAAA,CAAA;AAAA;AAAA,sBAAM,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAQ;AAAK,6BAAA,UAAU,CAAC,OAAD,EAAV,OAAU,CAAV;AAA0B,qBAAnD,CAAN,CAAA;;;AAAA,oBAAA,EAAA,CAAA,IAAA;;;;;;;AAIF,wBAAI,CAAC,GAAG,CAAC,SAAT,EAAoB;AAClB,sBAAA,GAAG,CAAC,SAAJ,GAAgB,EAAhB;AACD;;AAED,oBAAA,GAAG,CAAC,SAAJ,CAAc,QAAd,GAAyB,QAAzB;AACA,oBAAA,GAAG,CAAC,SAAJ,CAAc,eAAd,GAAgC,UAAhC;AACA,0BAAM,GAAN;;;;;;;;;;;;;;iBAxCG,I,EAAI,OAAA,CAAA;AAAA;AAAA,cAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;AA2CZ,GA9DK;;AA+DR,SAAA,qBAAA;AAAC,CAzFD,EAAA;;;;AA2FA,IAAM,UAAU,GAAG,UAAC,KAAD,EAAe;AAChC,MAAI,KAAK,YAAY,KAArB,EAA4B,OAAO,KAAP;AAC5B,MAAI,KAAK,YAAY,MAArB,EAA6B,OAAO,MAAM,CAAC,MAAP,CAAc,IAAI,KAAJ,EAAd,EAA2B,KAA3B,CAAP;AAC7B,MAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B,OAAO,IAAI,KAAJ,CAAU,KAAV,CAAP;AAC/B,SAAO,IAAI,KAAJ,CAAU,+BAA6B,KAAvC,CAAP;AACD,CALD","sourcesContent":["import { HttpRequest } from \"@aws-sdk/protocol-http\";\nimport { isThrottlingError } from \"@aws-sdk/service-error-classification\";\nimport { SdkError } from \"@aws-sdk/types\";\nimport { FinalizeHandler, FinalizeHandlerArguments, MetadataBearer, Provider, RetryStrategy } from \"@aws-sdk/types\";\nimport { v4 } from \"uuid\";\n\nimport { DEFAULT_MAX_ATTEMPTS, RETRY_MODES } from \"./config\";\nimport {\n  DEFAULT_RETRY_DELAY_BASE,\n  INITIAL_RETRY_TOKENS,\n  INVOCATION_ID_HEADER,\n  REQUEST_HEADER,\n  THROTTLING_RETRY_DELAY_BASE,\n} from \"./constants\";\nimport { getDefaultRetryQuota } from \"./defaultRetryQuota\";\nimport { defaultDelayDecider } from \"./delayDecider\";\nimport { defaultRetryDecider } from \"./retryDecider\";\nimport { DelayDecider, RetryDecider, RetryQuota } from \"./types\";\n\n/**\n * Strategy options to be passed to StandardRetryStrategy\n */\nexport interface StandardRetryStrategyOptions {\n  retryDecider?: RetryDecider;\n  delayDecider?: DelayDecider;\n  retryQuota?: RetryQuota;\n}\n\nexport class StandardRetryStrategy implements RetryStrategy {\n  private retryDecider: RetryDecider;\n  private delayDecider: DelayDecider;\n  private retryQuota: RetryQuota;\n  public mode: string = RETRY_MODES.STANDARD;\n\n  constructor(private readonly maxAttemptsProvider: Provider<number>, options?: StandardRetryStrategyOptions) {\n    this.retryDecider = options?.retryDecider ?? defaultRetryDecider;\n    this.delayDecider = options?.delayDecider ?? defaultDelayDecider;\n    this.retryQuota = options?.retryQuota ?? getDefaultRetryQuota(INITIAL_RETRY_TOKENS);\n  }\n\n  private shouldRetry(error: SdkError, attempts: number, maxAttempts: number) {\n    return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);\n  }\n\n  private async getMaxAttempts() {\n    let maxAttempts: number;\n    try {\n      maxAttempts = await this.maxAttemptsProvider();\n    } catch (error) {\n      maxAttempts = DEFAULT_MAX_ATTEMPTS;\n    }\n    return maxAttempts;\n  }\n\n  async retry<Input extends object, Ouput extends MetadataBearer>(\n    next: FinalizeHandler<Input, Ouput>,\n    args: FinalizeHandlerArguments<Input>,\n    options?: {\n      beforeRequest: Function;\n      afterRequest: Function;\n    }\n  ) {\n    let retryTokenAmount;\n    let attempts = 0;\n    let totalDelay = 0;\n\n    const maxAttempts = await this.getMaxAttempts();\n\n    const { request } = args;\n    if (HttpRequest.isInstance(request)) {\n      request.headers[INVOCATION_ID_HEADER] = v4();\n    }\n\n    while (true) {\n      try {\n        if (HttpRequest.isInstance(request)) {\n          request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;\n        }\n\n        if (options?.beforeRequest) {\n          await options.beforeRequest();\n        }\n        const { response, output } = await next(args);\n        if (options?.afterRequest) {\n          options.afterRequest(response);\n        }\n\n        this.retryQuota.releaseRetryTokens(retryTokenAmount);\n        output.$metadata.attempts = attempts + 1;\n        output.$metadata.totalRetryDelay = totalDelay;\n\n        return { response, output };\n      } catch (e) {\n        const err = asSdkError(e);\n        attempts++;\n        if (this.shouldRetry(err as SdkError, attempts, maxAttempts)) {\n          retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);\n          const delay = this.delayDecider(\n            isThrottlingError(err) ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE,\n            attempts\n          );\n          totalDelay += delay;\n\n          await new Promise((resolve) => setTimeout(resolve, delay));\n          continue;\n        }\n\n        if (!err.$metadata) {\n          err.$metadata = {};\n        }\n\n        err.$metadata.attempts = attempts;\n        err.$metadata.totalRetryDelay = totalDelay;\n        throw err;\n      }\n    }\n  }\n}\n\nconst asSdkError = (error: unknown): SdkError => {\n  if (error instanceof Error) return error;\n  if (error instanceof Object) return Object.assign(new Error(), error);\n  if (typeof error === \"string\") return new Error(error);\n  return new Error(`AWS SDK error wrapper for ${error}`);\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}