{"ast":null,"code":"import { __assign } from \"tslib\";\nexport var resolveCustomEndpointsConfig = function (input) {\n  var _a;\n\n  return __assign(__assign({}, input), {\n    tls: (_a = input.tls) !== null && _a !== void 0 ? _a : true,\n    endpoint: normalizeEndpoint(input),\n    isCustomEndpoint: true\n  });\n};\n\nvar normalizeEndpoint = function (input) {\n  var endpoint = input.endpoint,\n      urlParser = input.urlParser;\n\n  if (typeof endpoint === \"string\") {\n    var promisified_1 = Promise.resolve(urlParser(endpoint));\n    return function () {\n      return promisified_1;\n    };\n  } else if (typeof endpoint === \"object\") {\n    var promisified_2 = Promise.resolve(endpoint);\n    return function () {\n      return promisified_2;\n    };\n  }\n\n  return endpoint;\n};","map":{"version":3,"sources":["../../src/CustomEndpointsConfig.ts"],"names":[],"mappings":";AA8BA,OAAO,IAAM,4BAA4B,GAAG,UAC1C,KAD0C,EACgB;;;AACpB,SAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACnC,KADmC,CAAA,EAC9B;AACR,IAAA,GAAG,EAAE,CAAA,EAAA,GAAA,KAAK,CAAC,GAAN,MAAS,IAAT,IAAS,EAAA,KAAA,KAAA,CAAT,GAAS,EAAT,GAAa,IADV;AAER,IAAA,QAAQ,EAAE,iBAAiB,CAAC,KAAD,CAFnB;AAGR,IAAA,gBAAgB,EAAE;AAHV,GAD8B,CAAA;AAKtC,CAPK;;AASP,IAAM,iBAAiB,GAAG,UAAC,KAAD,EAAuD;AACvE,MAAA,QAAQ,GAAgB,KAAK,CAArB,QAAR;AAAA,MAAU,SAAS,GAAK,KAAK,CAAV,SAAnB;;AACR,MAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AAChC,QAAM,aAAW,GAAG,OAAO,CAAC,OAAR,CAAgB,SAAS,CAAC,QAAD,CAAzB,CAApB;AACA,WAAO,YAAA;AAAM,aAAA,aAAA;AAAW,KAAxB;AACD,GAHD,MAGO,IAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AACvC,QAAM,aAAW,GAAG,OAAO,CAAC,OAAR,CAAgB,QAAhB,CAApB;AACA,WAAO,YAAA;AAAM,aAAA,aAAA;AAAW,KAAxB;AACD;;AACD,SAAO,QAAP;AACD,CAVD","sourcesContent":["import { Endpoint, Provider, UrlParser } from \"@aws-sdk/types\";\n\nexport interface CustomEndpointsInputConfig {\n  /**\n   * The fully qualified endpoint of the webservice.\n   */\n  endpoint: string | Endpoint | Provider<Endpoint>;\n\n  /**\n   * Whether TLS is enabled for requests.\n   */\n  tls?: boolean;\n}\n\ninterface PreviouslyResolved {\n  urlParser: UrlParser;\n}\n\nexport interface CustomEndpointsResolvedConfig extends Required<CustomEndpointsInputConfig> {\n  /**\n   * Resolved value for input {@link CustomEndpointsInputConfig.endpoint}\n   */\n  endpoint: Provider<Endpoint>;\n  /**\n   * Whether the endpoint is specified by caller.\n   * @internal\n   */\n  isCustomEndpoint: true;\n}\n\nexport const resolveCustomEndpointsConfig = <T>(\n  input: T & CustomEndpointsInputConfig & PreviouslyResolved\n): T & CustomEndpointsResolvedConfig => ({\n  ...input,\n  tls: input.tls ?? true,\n  endpoint: normalizeEndpoint(input),\n  isCustomEndpoint: true,\n});\n\nconst normalizeEndpoint = (input: CustomEndpointsInputConfig & PreviouslyResolved): Provider<Endpoint> => {\n  const { endpoint, urlParser } = input;\n  if (typeof endpoint === \"string\") {\n    const promisified = Promise.resolve(urlParser(endpoint));\n    return () => promisified;\n  } else if (typeof endpoint === \"object\") {\n    const promisified = Promise.resolve(endpoint);\n    return () => promisified;\n  }\n  return endpoint;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}